---
type: Post
title: Understanding Cross-Site Request Forgery (CSRF)
description: >-
  Cross-site request forgery (also known as CSRF) is a web security
  vulnerability that allows an attacker to induce users to perform actions that
  they do not intend to perform. It allows an attacker to partly circumvent the
  same origin policy, which is designed to prevent different websites from
  interfering with each other.
date: '2024-11-09'
---
### 1. Understanding Cross-Site Request Forgery (CSRF)

Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.

#### Example Scenario of CSRF Exploitation

1.  **User Authentication**: A user logs into their bank account on a legitimate banking site, `bank.example.com`, and receives a session cookie.

2.  **Malicious Site**: The user then visits a malicious site controlled by an attacker.

3.  **CSRF Attack**: The malicious site contains a hidden form or script that sends a request to `bank.example.com` to transfer money. Because the user is authenticated, the browser includes the session cookie with the request.

4.  **Unauthorized Action**: The bank's server processes the request as if it was legitimately made by the user, transferring money to the attacker's account.

##### Attack Example 1

**Step-by-Step Attack Example**

1.       POST /login HTTP/1.1
         Host: bank.example.com
         Content-Type: application/x-www-form-urlencoded
         
         username=user&password=pass

2.      HTTP/1.1 200 OK
        Set-Cookie: sessionId=abc123; Path=/; Secure; HttpOnly

3.      <!-- evil.com -->
        <html>
        <body>
          <h1>Welcome to Evil.com</h1>
          <img src="http://bank.example.com/transfer?to=attacker&amount=1000" style="display:none;" />
        </body>
        </html>

4.      GET /transfer?to=attacker&amount=1000 HTTP/1.1
        Host: bank.example.com
        Cookie: sessionId=abc123

5.  **Server Action**: The bank server processes the request and transfers money to the attacker's account, believing it to be a legitimate request from the user.

##### Attack Example 2: Using a POST Request

If the bank server requires a POST request to transfer funds, an attacker can still exploit this by creating a hidden form on their malicious site. When the user visits the attacker's site, the form is automatically submitted using JavaScript.

**Attacker’s Malicious Site**:

    <!-- evil.com -->
    <html>
    <body>
      <h1>Welcome to Evil.com</h1>
      <form id="csrfForm" action="http://bank.example.com/transfer" method="POST">
        <input type="hidden" name="to" value="attacker">
        <input type="hidden" name="amount" value="1000">
      </form>
      <script>
        document.getElementById('csrfForm').submit();
      </script>
    </body>
    </html>

When the user visits `evil.com`, the hidden form is submitted automatically, sending the POST request with the session cookie included.

##### Attack Example 3: The API that transfer funds only accepts JSON

An HTML form cannot generate JSON, so form-based attacks will not work here. An HTML form can only carry three types of content types: `application/x-www-form-urlencoded`, `multipart/form-data`, and `text/plain`. However, we can use HTML forms to create JSON-like inputs, but we can't change the content-type to `application/json` without JavaScript. This attack will only work against a JSON POST endpoint that does not validate the content-type.

Code example.

**Attacker’s Malicious Site**:

    <!-- evil.com -->
    <html>
    <body>
      <h1>Welcome to Evil.com</h1>
      <form id="csrfForm" action="http://bank.example.com/transfer" method="POST" enctype="text/plain">
        <input type="hidden" name="{\"to\":\"attacker\",\"amount\":1000}" value="">
      </form>
      <script>
        document.getElementById('csrfForm').submit();
      </script>
    </body>
    </html>

The request that will be sent to the server will look like this:

    POST /transfer HTTP/1.1
    Host: bank.example.com
    Content-Type: text/plain
    Content-Length: 26

    {"to":"attacker","amount":1000}

### 2. Why CSRF is Possible Despite the Same-Origin Policy

The Same-Origin Policy (SOP) is a browser security mechanism that restricts how documents and scripts from one origin can interact with resources from another origin. It prevents websites from reading data from another site.

**However, SOP does not prevent the following**:

*   **Sending Requests**: The Same-Origin Policy does not block a web page from making requests to different origins. It only restricts reading the response data from these requests. Thus, a malicious website can send requests to another site using a logged-in user's credentials.

*   **Automatic Inclusion of Cookies**: Browsers automatically include cookies with every request to the domain that set them, regardless of the origin of the request. This is fundamental for maintaining session state but can be exploited in CSRF attacks.

### 3. Preventing CSRF Attacks

##### Add Captcha, SMS Verification, etc.

##### Add CSRF Token

To prevent CSRF attacks, we need to ensure that some information is "known only to the user." How do we achieve this?

We add a hidden field called `csrftoken` to the form. The server randomly generates the value of this field and stores it in the server’s session.

    <form id="csrfForm" action="http://bank.example.com/transfer" method="POST">
        <input type="hidden" name="to" value="attacker">
        <input type="hidden" name="amount" value="1000">
        <input type="hidden" name="csrftoken" value="fj1iro2jro12ijoi1"/>
        <input type="submit" value="Transfer"/>
    </form>

After submitting the form, the server compares the `csrftoken` in the form with the one stored in its session. If they match, it means that this is a legitimate request made by the user. The `csrftoken` is generated by the server and should be changed for each request.

This works because the attacker does not know the value of the `csrftoken` and cannot guess it, preventing the attack.

However, there is another scenario to consider. If your server supports cross-origin requests, an attacker could make a request from their page, successfully obtain the CSRF token, and launch an attack. But this is only possible if your server accepts requests from that domain.

##### Double Submit Cookie

The previous solution requires server state, meaning the CSRF token must be stored on the server. The advantage of the Double Submit Cookie solution is that it does not require the server to store anything.

In this solution, the server generates a random token and adds it to the form. Additionally, the client side sets a cookie named `csrftoken` with the same token value.

    Set-Cookie: csrftoken=fj1iro2jro12ijoi1

<!---->

    <form id="csrfForm" action="http://bank.example.com/transfer" method="POST">
        <input type="hidden" name="to" value="attacker">
        <input type="hidden" name="amount" value="1000">
        <input type="hidden" name="csrftoken" value="fj1iro2jro12ijoi1"/>
        <input type="submit" value="Transfer"/>
    </form>

When the user submits the form, the server compares the `csrftoken` in the cookie with the `csrftoken` in the form. If they are equal, it confirms the request is from the user.

This method is effective because an attacker cannot set the cookie of `bank.example.com` on their domain due to browser restrictions. Therefore, the `csrftoken` in the cookie of the request sent by the attacker will not exist, and the request will be blocked.

However, this method also has drawbacks. If the attacker controls any of your subdomains, they can set cookies and successfully attack you.

##### Client-side Double Submit Cookie

The reason why client-side is mentioned specifically is that the project I previously encountered was a Single Page Application. Searching the web, you will find people asking, “How can SPA get a CSRF token?” Do you need to provide another API from the server? This seems a bit strange.

However, I think we can use the spirit of Double Submit Cookie to solve this problem. The key to solving this problem is to generate the CSRF token from the client side. There is no need to interact with the server API.

The other processes are the same as before, generating and putting it into the form and writing it to the cookie. Or if you are an SPA, you can also directly put this information in the request header, and you don’t have to do this for every form, just add it in one place.

In fact, the library I often use, axios, provides such a function. You can set the header name and cookie name. After setting it up, every request it sends will automatically fill in the value in the cookie for you.

    // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
    xsrfCookieName: 'XSRF-TOKEN', // default

    // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
    xsrfHeaderName: 'X-XSRF-TOKEN', // default

The token can be generated by the client because it does not contain sensitive information; it simply prevents "attackers" from guessing it. The core concept of Double Submit Cookie is: "Attackers cannot read and write cookies of the target website, so the CSRF token in the request will differ from that in the cookie."

##### Browser’s Own Defense

CSRF vulnerabilities exist due to browser mechanisms. Is it possible to address this issue from the browser side? Yes, it is, and there are already solutions available, such as the SameSite cookie attribute.

Google officially added this feature in Chrome 51. For those interested in the detailed operation principle, please refer to draft-west-first-party-cookies-07.

First, let’s quote Google’s explanation:

Enabling this feature is very simple.

Your original cookie header looks like this:

    Set-Cookie: session_id=ewfewjf23o1;

You just need to add SameSite at the end:

    Set-Cookie: session_id=ewfewjf23o1; SameSite

However, there are two modes for SameSite: Lax and Strict, with the latter being the default. You can also specify the mode yourself:

    Set-Cookie: session_id=ewfewjf23o1; SameSite=Strict
    Set-Cookie: foo=bar; SameSite=Lax

Let’s first talk about the default Strict mode. When you add the SameSite keyword, it means “this cookie can only be used by the same site and should not be added to any cross-site requests.”

This means that after you add it, all the , , and new XMLHttpRequest requests that are not verified by the browser to be initiated from the same site will not carry this cookie.

However, this will cause a problem. If even  does not carry the cookie, when I click on a link from a Google search result or a link shared by a friend to enter a website, because the cookie is not carried, the website will become logged out. This is a very bad user experience.

There are two solutions. The first is like Amazon, where two sets of different cookies are prepared. The first set is used to maintain the login status, and the second set is used for sensitive operations (such as purchasing, account settings, etc.). The first set does not set SameSite, so no matter where you come from, you will be logged in. However, even if the attacker has the first set of cookies, they cannot do anything because they cannot perform any operations. The second set completely avoids CSRF because of the SameSite setting.

But this is still a bit troublesome, so you can consider the second solution, which is to adjust to the other mode of SameSite: Lax.

The Lax mode relaxes some restrictions. For example, , , and  will still carry the cookie. However, forms with POST methods or any methods such as POST, PUT, DELETE will not carry the cookie.

So on the one hand, you can maintain flexibility, allowing users to maintain their login status when entering your website from other websites, and on the other hand, you can prevent CSRF attacks. However, under the Lax mode, GET-based CSRF cannot be blocked, so this should be noted.



